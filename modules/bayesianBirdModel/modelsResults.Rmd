---
title: "Hierarchical Model"
author: "Tati Micheletti"
date: "26/04/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reproducible)
library(quickPlot)
library(usefun)
library(ggplot2)
library(data.table)
library(googledrive)
Require("basicMCMCplots")
modelsPath <- file.path(getwd(), "modules/bayesianBirdModel/data")
```

## Hierarchical scale model

### Model 1: 
Model 1 is composed of one equation, where the coefficients for disturbance come from the same hyperprior. 

```{r model1_design, eval=FALSE}
     ######## PRIORS ########
      #Zero inflation - habitat suitability
      phi ~ dunif(0, 1) # proportion of suitable sites (we need to keep phi between 0 and 1)
      
      # Coefficient for disturbance
      mu.beta ~ dnorm(0, 0.01)
      tau.beta <- pow(sd.beta, -2)
      sd.beta ~ dunif(0, 2) # cluster heterogeneity in lambda
      for (b in 1:Nbeta) {
        beta[b] ~ dnorm(mu.beta, tau.beta) # Hyperparameter for beta coefficients # No idea what to put here!
      }
      
      # Random effect
      tau.clusters <- pow(sd.cluster, -2)
      sd.cluster ~ dunif(0, 2) # year heterogeneity in lambda
      tau.year <- pow(sd.year, -2)
      sd.year ~ dunif(0, 2) # cluster heterogeneity in lambda
      for (j in 1:NClusters) {
        clusterRanEff[j] ~ dnorm(0, tau.clusters) # Note plural on tau.clusters, different than tau.cluster
        # random cluster effects in log(density)
      }
      for (y in 1:NYears) {
        YearRanEff[y] ~ dnorm(0, tau.year)
        # random year effects in log(density)
      }
      
      ##### END OF PRIORS ####
      
      for (i in 1:nvisits){ # each sample point / each row of the data table
        omega[i] ~ dbern(phi) # Habitat suitability --> zero inflation (if phi = 0, unsuitable)
        # Local scale
        yearInd <- YearIndex[i]
        clusterInd <- ClusterIndex[i]
        counts[i]  ~ dpois(mu.poisson[i])
        mu.poisson[i] <- omega[i] * lambda[i] 
        lambda[i] <- exp(loglambda[i])
        loglambda[i] <- density[i] + beta[1] * State_P_500[i] + beta[2] * State_P_100[i] + offset[i] + 
          clusterRanEff[clusterInd] * switchCluster +
          YearRanEff[yearInd] * switchYear # Random Effects
      } # end i
```

#### Loading 

```{r load1, echo=TRUE}
model1 <- prepInputs(url = "https://drive.google.com/open?id=1jZHlCKP8goQZ1W-nFXcaiBabxSTzEQv4",
                     destinationPath = file.path(getwd(), "outputs/posthocAnalysis/bayesian/"),
                     fun = "readRDS", targetFile = "model1.rds")
```

#### Plots  

First of all, we should check chain mixing. We use the function `chainsPlot` from the package `basicMCMCplots`. OBS.: These will likely not work in RStudio server.

```{r chains1, echo = TRUE, eval = FALSE}
betaChain <- prepParamForChainCheck(samplesList = model1$samples, param = "beta")
basicMCMCplots::chainsPlot(samplesList = betaChain)
basicMCMCplots::chainsSummary(samplesList = betaChain)
basicMCMCplots::samplesPlot(samples = betaChain)
```


After looking into chain mixing, we check lambda. Note that this is the summary average, not original posterior.
```{r lambda1, echo = TRUE}
# Original densities
originalDensities <- prepInputs(url = "https://drive.google.com/open?id=1KOmGJxRivRNgc8AAoCrinl7-ZHQOPUGm",
                     destinationPath = file.path(getwd(), "outputs/posthocAnalysis/bayesian/"),
                     fun = "readRDS")
model1DT <- data.table(model1$summary$all.chains, keep.rownames = TRUE)
lambda <- model1DT[rn %in% grepMulti(model1DT$rn, patterns = "lambda"),] 
hist(originalDensities, main = "Average density: Original", xlim = c(0, 3), breaks = 15) # Average density
hist(lambda[, Mean], main = "Average density: Model 1", xlim = c(0, 3), breaks = 30) # Average density
```

Now the coefficient for disturbance, beta. Beta[1] is the neighborhood disturbance coefficient, and beta[2] is the local disturbance coefficient.
```{r beta1, echo = TRUE}
beta <- c(grepMulti(model1DT$rn, patterns = c("beta", "1")),
                   grepMulti(model1DT$rn, patterns = c("beta", "2")),
                   grepMulti(model1DT$rn, patterns = c("beta", "mu")))
dt <- data.frame(model1DT[rn %in% beta,c("rn", "Mean")])
boxplot(Mean ~ rn, data = dt, main = "Disturbance Coefficients: Model 1", xlab = "beta[1] = neighborhood; beta[2] = local\n mu.beta = hyperparameter average")
```

Now we look at the random effects for parameters: Year and Cluster
```{r RE1, echo = TRUE}
RE <- c(grepMulti(model1DT$rn, patterns = c("YearRanEff")),
          grepMulti(model1DT$rn, patterns = c("clusterRanEff")))
model1DT[rn %in% RE,]
dtRE <- data.frame(model1DT[rn %in% RE, c("rn", "Mean")])
# count how many 
ys <- length(grepMulti(dtRE$rn, "Year"))
dtRE$RE <- c(rep("YearRandomEffect", times = ys), rep("ClusterRandomEffect", times = NROW(dtRE)-ys))
boxplot(Mean ~ RE, data = dtRE, main = "Random effects: Model 1")
```

At last, we check habitat suitability: omega
```{r omega1, echo = TRUE}
chain1 <- data.table(model1$samples$chain1, keep.rownames = TRUE, check.names = TRUE)
omegaNames <- grepMulti(names(chain1), patterns = "omega")
omega <- chain1[, grepMulti(names(chain1), patterns = "omega")]
chain1Omega <- as.numeric(unlist(x = chain1[, ..omega], recursive = TRUE))

chain2 <- data.table(model1$samples$chain2, keep.rownames = TRUE, check.names = TRUE)
omegaNames <- grepMulti(names(chain2), patterns = "omega")
omega <- chain2[, grepMulti(names(chain2), patterns = "omega")]
allOmega <- c(chain1Omega, as.numeric(unlist(x = chain2[, ..omega], recursive = TRUE)))
hist(allOmega, main = "Average Habitat Suitability: Model 1", xlab = "omega")
```


### Model 2: 
Model 2 is composed of two equations, one for neighborhood, one for local. Neighborhood lambda has a poisson distribution, and the coefficients for disturbance come from the same hyperprior.  
OBS.: NN needs to be initialized as well as local lambda

```{r model2_design, eval=FALSE}
          ######## PRIORS ########
      #Zero inflation - habitat suitability
      phi ~ dunif(0, 1) # proportion of suitable sites (we need to keep phi between 0 and 1)
      
      # Coefficient for disturbance
      mu.beta ~ dnorm(0, 0.01)
      tau.beta <- pow(sd.beta, -2)
      sd.beta ~ dunif(0, 2) # cluster heterogeneity in lambda
      for (b in 1:Nbeta) {
        beta[b] ~ dnorm(mu.beta, tau.beta) # Hyperparameter for beta coefficients # No idea what to put here!
      }
      
      # Random effect
      tau.clusters <- pow(sd.cluster, -2)
      sd.cluster ~ dunif(0, 2) # year heterogeneity in lambda
      tau.year <- pow(sd.year, -2)
      sd.year ~ dunif(0, 2) # cluster heterogeneity in lambda
      for (j in 1:NClusters) {
        clusterRanEff[j] ~ dnorm(0, tau.clusters) # Note plural on tau.clusters, different than tau.cluster
        # random cluster effects in log(density)
      }
      for (y in 1:NYears) {
        YearRanEff[y] ~ dnorm(0, tau.year)
        # random year effects in log(density)
      }
      
      ##### END OF PRIORS ####
      
      for (i in 1:nvisits){ # each sample point / each row of the data table
        omega[i] ~ dbern(phi) # Habitat suitability --> zero inflation (if phi = 0, unsuitable)
        # Neighborhood scale
        yearInd <- YearIndex[i]
        clusterInd <- ClusterIndex[i]
        
        NN[i] ~ dpois(lambdaN[i])
        lambdaN[i] <- exp(loglambdaN[i])
        
        loglambdaN[i] <- density[i] +
          beta[1] * State_P_500[i] +
          offset[i] +
          clusterRanEff[clusterInd] * switchCluster +
          YearRanEff[yearInd] * switchYear # Random Effects
        
        # Local scale
        counts[i]  ~ dpois(lambdaLOmega[i])
        lambdaLOmega[i] <- omega[i] * lambdaL[i] 
        lambdaL[i] <- exp(loglambdaL[i])
        loglambdaL[i] <- NN[i] + beta[2] * State_P_100[i] # We can add an interceptL to NN?
      } # end i
```

#### Loading 

```{r load2, echo=TRUE}
model2 <- prepInputs(url = "https://drive.google.com/open?id=1774Hwx9yFVkOn58eI5rEdGTerve6aqOA",
                     destinationPath = file.path(getwd(), "outputs/posthocAnalysis/bayesian/"),
                     fun = "readRDS", targetFile = "model2.rds")
```

#### Plots  

First of all, we should check chain mixing. We use the function `chainsPlot` from the package `basicMCMCplots`. OBS.: These will likely not work in RStudio server.

```{r chains2, echo = TRUE, eval = FALSE}
betaChain2 <- prepParamForChainCheck(samplesList = model2$samples, param = "beta")
basicMCMCplots::chainsPlot(samplesList = betaChain2)
basicMCMCplots::chainsSummary(samplesList = betaChain2)
basicMCMCplots::samplesPlot(samples = betaChain2)
```

After looking into chain mixing, we check lambda. Note that this is the summary average, not original posterior.
```{r lambda2, echo = TRUE}
# Estimated densities
model2DT <- data.table(model2$summary$all.chains, keep.rownames = TRUE)
lambdaL <- model2DT[rn %in% grepMulti(model2DT$rn, patterns = "lambdaL"),]
lambdaN <- model2DT[rn %in% grepMulti(model2DT$rn, patterns = "lambdaN"),]
hist(originalDensities, main = "Average density: Original", xlim = c(0, 3), breaks = 15) # Average density
hist(lambdaL[,Mean], main = "Average density local: Model 2", xlim = c(0, 3), breaks = 30) # Average density
hist(lambdaN[,Mean], main = "Average density neighborhood: Model 2", xlim = c(0, 3), breaks = 30) # Average density
```

Now the coefficient for disturbance, beta. Beta[1] is the neighborhood disturbance coefficient, and beta[2] is the local disturbance coefficient.
```{r beta2, echo = TRUE}
beta <- c(grepMulti(model2DT$rn, patterns = c("beta", "1")),
                   grepMulti(model2DT$rn, patterns = c("beta", "2")),
                   grepMulti(model2DT$rn, patterns = c("beta", "mu")))
dt <- data.frame(model2DT[rn %in% beta,c("rn", "Mean")])
boxplot(Mean ~ rn, data = dt, main = "Disturbance Coefficients: Model 2", xlab = "beta[1] = neighborhood; beta[2] = local\n mu.beta = hyperparameter average")
```

Now we look at the random effects for parameters: Year and Cluster
```{r RE2, echo = TRUE}
RE <- c(grepMulti(model2DT$rn, patterns = c("YearRanEff")),
          grepMulti(model2DT$rn, patterns = c("clusterRanEff")))
model2DT[rn %in% RE,]
dtRE <- data.frame(model2DT[rn %in% RE, c("rn", "Mean")])
# count how many 
ys <- length(grepMulti(dtRE$rn, "Year"))
dtRE$RE <- c(rep("YearRandomEffect", times = ys), rep("ClusterRandomEffect", times = NROW(dtRE)-ys))
boxplot(Mean ~ RE, data = dtRE, main = "Random effects: Model 2")
```

At last, we check habitat suitability: omega
```{r omega2, echo = TRUE}
chain2 <- data.table(model2$samples$chain2, keep.rownames = TRUE, check.names = TRUE)
omegaNames <- grepMulti(names(chain2), patterns = "omega")
omega <- chain2[, grepMulti(names(chain2), patterns = "omega")]
chain2Omega <- as.numeric(unlist(x = chain2[, ..omega], recursive = TRUE))

chain2 <- data.table(model2$samples$chain2, keep.rownames = TRUE, check.names = TRUE)
omegaNames <- grepMulti(names(chain2), patterns = "omega")
omega <- chain2[, grepMulti(names(chain2), patterns = "omega")]
allOmega <- c(chain2Omega, as.numeric(unlist(x = chain2[, ..omega], recursive = TRUE)))
hist(allOmega, main = "Average Habitat Suitability: Model 2", xlab = "omega")
```

### Model 3: 
Model 3 is composed of one equation, where the coefficients for disturbance come from the same hyperprior, but has no Zero Inflation.
```{r model3_design, eval=FALSE}
     ######## PRIORS ########
      #Zero inflation - habitat suitability
      
      # Coefficient for disturbance
      mu.beta ~ dnorm(0, 0.01)
      tau.beta <- pow(sd.beta, -2)
      sd.beta ~ dunif(0, 2) # cluster heterogeneity in lambda
      for (b in 1:Nbeta) {
        beta[b] ~ dnorm(mu.beta, tau.beta) # Hyperparameter for beta coefficients # No idea what to put here!
      }
      
      # Random effect
      tau.clusters <- pow(sd.cluster, -2)
      sd.cluster ~ dunif(0, 2) # year heterogeneity in lambda
      tau.year <- pow(sd.year, -2)
      sd.year ~ dunif(0, 2) # cluster heterogeneity in lambda
      for (j in 1:NClusters) {
        clusterRanEff[j] ~ dnorm(0, tau.clusters) # Note plural on tau.clusters, different than tau.cluster
        # random cluster effects in log(density)
      }
      for (y in 1:NYears) {
        YearRanEff[y] ~ dnorm(0, tau.year)
        # random year effects in log(density)
      }
      
      ##### END OF PRIORS ####
      
      for (i in 1:nvisits){ # each sample point / each row of the data table
        # Local scale
        yearInd <- YearIndex[i]
        clusterInd <- ClusterIndex[i]
        counts[i]  ~ dpois(lambda[i])
        lambda[i] <- exp(loglambda[i])
        loglambda[i] <- density[i] + beta[1] * State_P_500[i] + beta[2] * State_P_100[i] + offset[i] + 
          clusterRanEff[clusterInd] * switchCluster +
          YearRanEff[yearInd] * switchYear # Random Effects
      } # end i
```

#### Loading 

```{r load3, echo=TRUE}
model3 <- prepInputs(url = "https://drive.google.com/open?id=1UWoaLN1lNOjVQBSzSD2WpA1185i1x9ne",
                     destinationPath = file.path(getwd(), "outputs/posthocAnalysis/bayesian/"),
                     fun = "readRDS", targetFile = "model3.rds")
```

#### Plots  

First of all, we should check chain mixing. We use the function `chainsPlot` from the package `basicMCMCplots`. OBS.: These will likely not work in RStudio server.

```{r chains3, echo = TRUE, eval = FALSE}
betaChain3 <- prepParamForChainCheck(samplesList = model3$samples, param = "beta")
basicMCMCplots::chainsPlot(samplesList = betaChain3)
basicMCMCplots::chainsSummary(samplesList = betaChain3)
basicMCMCplots::samplesPlot(samples = betaChain3)
```


After looking into chain mixing, we check lambda. Note that this is the summary average, not original posterior.
```{r lambda3, echo = TRUE}
# Original densities
originalDensities <- prepInputs(url = "https://drive.google.com/open?id=1KOmGJxRivRNgc8AAoCrinl7-ZHQOPUGm",
                     destinationPath = file.path(getwd(), "outputs/posthocAnalysis/bayesian/"),
                     fun = "readRDS")
model3DT <- data.table(model3$summary$all.chains, keep.rownames = TRUE)
lambda <- model3DT[rn %in% grepMulti(model3DT$rn, patterns = "lambda"),] 
hist(originalDensities, main = "Average density: Original", xlim = c(0, 3), breaks = 15) # Average density
hist(lambda[, Mean], main = "Average density: Model 3", xlim = c(0, 3), breaks = 30) # Average density
```

Now the coefficient for disturbance, beta. Beta[1] is the neighborhood disturbance coefficient, and beta[2] is the local disturbance coefficient.
```{r beta3, echo = TRUE}
beta <- c(grepMulti(model3DT$rn, patterns = c("beta", "1")),
                   grepMulti(model3DT$rn, patterns = c("beta", "2")),
                   grepMulti(model3DT$rn, patterns = c("beta", "mu")))
dt <- data.frame(model3DT[rn %in% beta,c("rn", "Mean")])
boxplot(Mean ~ rn, data = dt, main = "Disturbance Coefficients: Model 3", xlab = "beta[1] = neighborhood; beta[2] = local\n mu.beta = hyperparameter average")
```

Now we look at the random effects for parameters: Year and Cluster
```{r RE3, echo = TRUE}
RE <- c(grepMulti(model3DT$rn, patterns = c("YearRanEff")),
          grepMulti(model3DT$rn, patterns = c("clusterRanEff")))
model3DT[rn %in% RE,]
dtRE <- data.frame(model3DT[rn %in% RE, c("rn", "Mean")])
# count how many 
ys <- length(grepMulti(dtRE$rn, "Year"))
dtRE$RE <- c(rep("YearRandomEffect", times = ys), rep("ClusterRandomEffect", times = NROW(dtRE)-ys))
boxplot(Mean ~ RE, data = dtRE, main = "Random effects: Model 3")
```

### Model 4: 
Model 4 is composed of two equations, one for neighborhood, one for local. Neighborhood lambda has a poisson distribution, and the coefficients for disturbance come from the same hyperprior, but no Zero Inflation.
OBS.: NN needs to be initialized as well as local lambda

```{r model4_design, eval=FALSE}
      ######## PRIORS ########
      # Coefficient for disturbance
      mu.beta ~ dnorm(0, 0.01)
      tau.beta <- pow(sd.beta, -2)
      sd.beta ~ dunif(0, 2) # cluster heterogeneity in lambda
      for (b in 1:Nbeta) {
        beta[b] ~ dnorm(mu.beta, tau.beta) # Hyperparameter for beta coefficients # No idea what to put here!
      }
      
      # Random effect
      tau.clusters <- pow(sd.cluster, -2)
      sd.cluster ~ dunif(0, 2) # year heterogeneity in lambda
      tau.year <- pow(sd.year, -2)
      sd.year ~ dunif(0, 2) # cluster heterogeneity in lambda
      for (j in 1:NClusters) {
        clusterRanEff[j] ~ dnorm(0, tau.clusters) # Note plural on tau.clusters, different than tau.cluster
        # random cluster effects in log(density)
      }
      for (y in 1:NYears) {
        YearRanEff[y] ~ dnorm(0, tau.year)
        # random year effects in log(density)
      }
      
      ##### END OF PRIORS ####
      
      for (i in 1:nvisits){ # each sample point / each row of the data table
        # Neighborhood scale
        yearInd <- YearIndex[i]
        clusterInd <- ClusterIndex[i]
        
        NN[i] ~ dpois(lambdaN[i])
        lambdaN[i] <- exp(loglambdaN[i])
        
        loglambdaN[i] <- density[i] +
          beta[1] * State_P_500[i] +
          offset[i] +
          clusterRanEff[clusterInd] * switchCluster +
          YearRanEff[yearInd] * switchYear # Random Effects
        
        # Local scale
        counts[i]  ~ dpois(lambdaL[i])
        lambdaL[i] <- exp(loglambdaL[i])
        loglambdaL[i] <- NN[i] + beta[2] * State_P_100[i] # We can add an interceptL to NN?
      } # end i
```

#### Loading 

```{r load4, echo=TRUE}
model4 <- prepInputs(url = "https://drive.google.com/open?id=1YvG-FFvimDB_hHtSCsYfeZY9rwKfDjue",
                     destinationPath = file.path(getwd(), "outputs/posthocAnalysis/bayesian/"),
                     fun = "readRDS", targetFile = "model4.rds")
```

#### Plots  

First of all, we should check chain mixing. We use the function `chainsPlot` from the package `basicMCMCplots`. OBS.: These will likely not work in RStudio server.

```{r chains4, echo = TRUE, eval = FALSE}
betaChain4 <- prepParamForChainCheck(samplesList = model4$samples, param = "beta")
basicMCMCplots::chainsPlot(samplesList = betaChain4)
basicMCMCplots::chainsSummary(samplesList = betaChain4)
basicMCMCplots::samplesPlot(samples = betaChain4)
```

After looking into chain mixing, we check lambda. Note that this is the summary average, not original posterior.
```{r lambda4, echo = TRUE}
# Estimated densities
model4DT <- data.table(model4$summary$all.chains, keep.rownames = TRUE)
lambdaL <- model4DT[rn %in% grepMulti(model4DT$rn, patterns = "lambdaL"),]
lambdaN <- model4DT[rn %in% grepMulti(model4DT$rn, patterns = "lambdaN"),]
hist(originalDensities, main = "Average density: Original", xlim = c(0, 3), breaks = 15) # Average density
hist(lambdaL[,Mean], main = "Average density local: Model 4", xlim = c(0, 3), breaks = 30) # Average density
hist(lambdaN[,Mean], main = "Average density neighborhood: Model 4", xlim = c(0, 3), breaks = 30) # Average density
```

Now the coefficient for disturbance, beta. Beta[1] is the neighborhood disturbance coefficient, and beta[2] is the local disturbance coefficient.
```{r beta4, echo = TRUE}
beta <- c(grepMulti(model4DT$rn, patterns = c("beta", "1")),
                   grepMulti(model4DT$rn, patterns = c("beta", "2")),
                   grepMulti(model4DT$rn, patterns = c("beta", "mu")))
dt <- data.frame(model4DT[rn %in% beta,c("rn", "Mean")])
boxplot(Mean ~ rn, data = dt, main = "Disturbance Coefficients: Model 4", xlab = "beta[1] = neighborhood; beta[2] = local\n mu.beta = hyperparameter average")
```

Now we look at the random effects for parameters: Year and Cluster
```{r RE4, echo = TRUE}
RE <- c(grepMulti(model4DT$rn, patterns = c("YearRanEff")),
          grepMulti(model4DT$rn, patterns = c("clusterRanEff")))
model4DT[rn %in% RE,]
dtRE <- data.frame(model4DT[rn %in% RE, c("rn", "Mean")])
# count how many 
ys <- length(grepMulti(dtRE$rn, "Year"))
dtRE$RE <- c(rep("YearRandomEffect", times = ys), rep("ClusterRandomEffect", times = NROW(dtRE)-ys))
boxplot(Mean ~ RE, data = dtRE, main = "Random effects: Model 4")
```


### Model 5: 
Model 5 is composed of one equation, where the coefficients for disturbance come from the same hyperprior, but has no Zero Inflation.
```{r model5_design, eval=FALSE}

```

#### Loading 

```{r load5, echo=TRUE}
model5 <- prepInputs(url = "https://drive.google.com/open?id=1QauVdsz4OQ0z9mrK8iGchIkOv2paq7Zy",
                     destinationPath = file.path(getwd(), "outputs/posthocAnalysis/bayesian/"),
                     fun = "readRDS", targetFile = "model5.rds")
```

#### Plots  

First of all, we should check chain mixing. We use the function `chainsPlot` from the package `basicMCMCplots`. OBS.: These will likely not work in RStudio server.

```{r chains5, echo = TRUE, eval = FALSE}
basicMCMCplots::chainsPlot(samplesList = model5$samples)
basicMCMCplots::chainsSummary(samplesList = model5$samples)
basicMCMCplots::samplesPlot(samples = model5$samples)
```
=======
*Model 1 (one equation + ZI)*  

*Model 2 (two equations + ZI)*  

*Model 3 (one equation no ZI)*  
  
*Model 4 (two equations no ZI)*  
>>>>>>> 86003e2efc6ddfeca9cb7e26694c624865611e55


After looking into chain mixing, we check lambda. Note that this is the summary average, not original posterior.
```{r lambda5, echo = TRUE}
# Original densities
originalDensities <- prepInputs(url = "https://drive.google.com/open?id=1KOmGJxRivRNgc8AAoCrinl7-ZHQOPUGm",
                     destinationPath = file.path(getwd(), "outputs/posthocAnalysis/bayesian/"),
                     fun = "readRDS")
model5DT <- data.table(model5$summary$all.chains, keep.rownames = TRUE)
lambda <- model5DT[rn %in% grepMulti(model5DT$rn, patterns = "lambda"),] 
hist(originalDensities, main = "Average density: Original", xlim = c(0, 3), breaks = 15) # Average density
hist(lambda[, Mean], main = "Average density: Model 5", xlim = c(0, 3), breaks = 30) # Average density
```

Now the coefficient for disturbance, beta. Beta[1] is the neighborhood disturbance coefficient, and beta[2] is the local disturbance coefficient.
```{r beta5, echo = TRUE}
beta <- c(grepMulti(model5DT$rn, patterns = c("beta", "1")),
                   grepMulti(model5DT$rn, patterns = c("beta", "2")),
                   grepMulti(model5DT$rn, patterns = c("beta", "mu")))
dt <- data.frame(model5DT[rn %in% beta,c("rn", "Mean")])
boxplot(Mean ~ rn, data = dt, main = "Disturbance Coefficients: Model 5", xlab = "beta[1] = neighborhood; beta[2] = local\n mu.beta = hyperparameter average")
```

Now we look at the random effects for parameters: Year and Cluster
```{r RE5, echo = TRUE}
RE <- c(grepMulti(model5DT$rn, patterns = c("YearRanEff")),
          grepMulti(model5DT$rn, patterns = c("clusterRanEff")))
model5DT[rn %in% RE,]
dtRE <- data.frame(model5DT[rn %in% RE, c("rn", "Mean")])
# count how many 
ys <- length(grepMulti(dtRE$rn, "Year"))
dtRE$RE <- c(rep("YearRandomEffect", times = ys), rep("ClusterRandomEffect", times = NROW(dtRE)-ys))
boxplot(Mean ~ RE, data = dtRE, main = "Random effects: Model 5")
```

### Model 6: 
Model 6 is composed of two equations, one for neighborhood, one for local. Neighborhood lambda has a poisson distribution, and the coefficients for disturbance come from the same hyperprior, but no Zero Inflation.
OBS.: NN needs to be initialized as well as local lambda

```{r model6_design, eval=FALSE}
  
```

#### Loading 

```{r load6, echo=TRUE}
model6 <- prepInputs(url = "https://drive.google.com/open?id=1_fk6sxP_yu2pDI_LCPbVlwTiK855UwJe",
                     destinationPath = file.path(getwd(), "outputs/posthocAnalysis/bayesian/"),
                     fun = "readRDS", targetFile = "model6.rds")
```

#### Plots  

First of all, we should check chain mixing. We use the function `chainsPlot` from the package `basicMCMCplots`. OBS.: These will likely not work in RStudio server.

```{r chains6, echo = TRUE, eval = FALSE}
basicMCMCplots::chainsPlot(samplesList = model6$samples)
basicMCMCplots::chainsSummary(samplesList = model6$samples)
basicMCMCplots::samplesPlot(samples = model6$samples)
```

After looking into chain mixing, we check lambda. Note that this is the summary average, not original posterior.
```{r lambda6, echo = TRUE}
# Estimated densities
model6DT <- data.table(model6$summary$all.chains, keep.rownames = TRUE)
lambdaL <- model6DT[rn %in% grepMulti(model6DT$rn, patterns = "lambdaL"),]
lambdaN <- model6DT[rn %in% grepMulti(model6DT$rn, patterns = "lambdaN"),]
hist(originalDensities, main = "Average density: Original", xlim = c(0, 3), breaks = 15) # Average density
hist(lambdaL[,Mean], main = "Average density local: Model 6", xlim = c(0, 3), breaks = 30) # Average density
hist(lambdaN[,Mean], main = "Average density neighborhood: Model 6", xlim = c(0, 3), breaks = 30) # Average density
```

Now the coefficient for disturbance, beta. Beta[1] is the neighborhood disturbance coefficient, and beta[2] is the local disturbance coefficient.
```{r beta6, echo = TRUE}
beta <- c(grepMulti(model6DT$rn, patterns = c("beta", "1")),
                   grepMulti(model6DT$rn, patterns = c("beta", "2")),
                   grepMulti(model6DT$rn, patterns = c("beta", "mu")))
dt <- data.frame(model6DT[rn %in% beta,c("rn", "Mean")])
boxplot(Mean ~ rn, data = dt, main = "Disturbance Coefficients: Model 6", xlab = "beta[1] = neighborhood; beta[2] = local\n mu.beta = hyperparameter average")
```

Now we look at the random effects for parameters: Year and Cluster
```{r RE6, echo = TRUE}
RE <- c(grepMulti(model6DT$rn, patterns = c("YearRanEff")),
          grepMulti(model6DT$rn, patterns = c("clusterRanEff")))
model6DT[rn %in% RE,]
dtRE <- data.frame(model6DT[rn %in% RE, c("rn", "Mean")])
# count how many 
ys <- length(grepMulti(dtRE$rn, "Year"))
dtRE$RE <- c(rep("YearRandomEffect", times = ys), rep("ClusterRandomEffect", times = NROW(dtRE)-ys))
boxplot(Mean ~ RE, data = dtRE, main = "Random effects: Model 6")
```


## Results summary:




