---
title: "Hierarchical Model"
author: "Tati Micheletti"
date: "26/04/2020"
output: html_document
---

```{r setup, include=FALSE, eval = TRUE}
knitr::opts_chunk$set(echo = TRUE)
library(reproducible)
library(quickPlot)
library(usefun)
library(ggplot2)
library(data.table)
library(googledrive)
reproducible::Require("basicMCMCplots")
modelsPath <- file.path(getwd(), "modules/bayesianBirdModel/data")
prepParamForChainCheck <- function(samplesList, param, unwantted){
  redChain <- lapply(samplesList, function(chain){
    nms <- usefun::grepMulti(pattern = param, unwanted = unwantted, x = colnames(chain))
    chanRed <- chain[, nms]
    return(chanRed)
    })
  return(redChain)
}
TRIAL <- "trial6"
destPath <- reproducible::checkPath(file.path(getwd(), "outputs/posthocAnalysis/bayesian", TRIAL), 
                                                               create = TRUE)
Checksums(destPath, write = TRUE)
```

## Hierarchical scale model

Before checking the models, here is the correlation between the variables disturbanceLocal and disturbanceNeighborhood
```{r corrOriginal}
OriginalData <- prepInputs(url = "https://drive.google.com/open?id=18Ii_g3wBGftmatCdNZLJdtczc5tzgwlW", 
                           destinationPath = dirname(destPath), fun = "readRDS")
plot(OriginalData$State_P_500, 
     OriginalData$State_P_100, xlab = "State_P_500 - neighborhood", ylab = "State_P_100 - local", 
     main = "Original Data")
mod <- lm(data = OriginalData, State_P_500 ~ State_P_100)
tab <- summary(mod)
abline(mod, col = "red")
mtext(paste0("cor = ", round(cor(OriginalData$State_P_100, OriginalData$State_P_500), 3), 
             "\nadj.R^2 = ", round(tab$adj.r.squared, 3)), 3, line = -0.2)
```


### Model 1: 
Model 1 is composed of one equation, where the coefficients for disturbance come from the same hyperprior. 

```{r model1_design, eval=FALSE}
        #MODEL 1: 1 equation + ZI
    iSMCode <- nimbleCode({
      
      ######## PRIORS ########
      #Zero inflation - habitat suitability
      phi ~ dunif(0, 1) # proportion of suitable sites (we need to keep phi between 0 and 1)
      
      # Coefficient for disturbance
      mu.beta ~ dunif(-40, 40)
      tau.beta ~ T(dgamma(1, 1), 0.01, 100)
      sd.beta <- 1/pow(tau.beta, 2) # cluster heterogeneity in lambda
      for (b in 1:Nbeta) {
        beta[b] ~ dnorm(mu.beta, tau.beta) # Hyperparameter for beta coefficients # No idea what to put here!
      }
      
      # Random effect
      tau.clusters ~ T(dgamma(1, 1), 0.01, 100)
      sd.cluster <- 1/pow(tau.clusters, 2) # year heterogeneity in lambda
      tau.year ~ T(dgamma(1, 1), 0.01, 100)
      sd.year <- 1/pow(tau.year, 2) # cluster heterogeneity in lambda
      for (j in 1:NClusters) {
        clusterRanEff[j] ~ dnorm(0, tau.clusters) # Note plural on tau.clusters, different than tau.clusters
        # random cluster effects in log(density)
      }
      for (y in 1:NYears) {
        YearRanEff[y] ~ dnorm(0, tau.year)
        # random year effects in log(density)
      }
      
      ##### END OF PRIORS ####
      
      for (i in 1:nvisits){ # each sample point / each row of the data table
        omega[i] ~ dbern(phi) # Habitat suitability --> zero inflation (if phi = 0, unsuitable)
        # Local scale
        yearInd <- YearIndex[i]
        clusterInd <- ClusterIndex[i]
        counts[i]  ~ dpois(mu.poisson[i])
        mu.poisson[i] <- omega[i] * lambda[i] 
        lambda[i] <- exp(loglambda[i])
        loglambda[i] <- logDensity[i] + beta[1] * State_P_500[i] + beta[2] * State_P_100[i] + offset[i] + 
          clusterRanEff[clusterInd] * switchCluster +
          YearRanEff[yearInd] * switchYear # Random Effects
      } # end i
    })
    
    ################################### MODEL
    
    # Data (doesn't need init)
    iSMdata <- list(counts = currentYearBirdData$counts,  
                    logDensity = currentYearBirdData$density,
                    State_P_100 = currentYearBirdData$State_P_100,
                    State_P_500 = currentYearBirdData$State_P_500,
                    offset = currentYearBirdData$offset,
                    ClusterIndex = currentYearBirdData$ClusterSP,
                    YearIndex = currentYearBirdData$YYYY)
    # Constants
    nvisits <- NROW(currentYearBirdData)
    NClusters <- length(unique(currentYearBirdData$ClusterSP))
    NYears <- length(unique(currentYearBirdData$YYYY))
    Nbeta <- 2 # Number of different beta coefficients (coming from the same hyperparameter)
    iSMconstants <- list(nvisits = nvisits,
                         NClusters = NClusters,
                         NYears = NYears,
                         Nbeta = Nbeta, # number of coefficients, currently: beta[1] and beta[2]
                         # Switches
                         switchYear = 1, # or 0 to turn off random effects of Year
                         switchCluster = 1 # or 0 to turn off random effects of Cluster
    )
    
    iSMinits <- list(
      # Coefficients
      phi = runif(1, 0, 1), # ZI part (‘suitability’ of the sample site).
      beta = rep(0, times = Nbeta), # Coefficient for disturbance ~ Has distribution, not sure need to provide
      omega = rep(1, times = nvisits), # Bernoulli of phi, sample site ‘suitability’ ~ Has distribution, not sure need to provide
      tau.year = runif(1, 0.01, 10), # Deviation of year RE ~ Has distribution
      tau.clusters = runif(1, 0.01, 10), # Deviation of cluester RE ~ Has distribution
      tau.beta = runif(1, 0.01, 10), # Deviation of beta hyperparameter ~ Has distribution
      mu.beta = 0,
      YearRanEff = rep(0, times = NYears),
      clusterRanEff = rep(0, times = NClusters)
    )

    params <- c("beta", "mu.beta", "tau.beta", "sd.beta", 
                "lambda", "omega", "phi", 
                "clusterRanEff", "YearRanEff", 
                "mu.poisson")
  }
```

#### Loading 

```{r load1, echo=TRUE}
whichModel <- "Model 1"
model1 <- prepInputs(url = "https://drive.google.com/open?id=16fvWSrO0ITVH64NwP5xPXKT5IP6KLi9f", 
                       # TRIAL 5: "https://drive.google.com/open?id=1eMgRiHnDoVLJqMXpUE75YeIwVnRI2U29",
                       # TRIAL 4: "https://drive.google.com/open?id=1Hw8CcQ7tSkHtR5cx-1JCRAUYuz3JRCUH",
                       # TRIAL3: "https://drive.google.com/open?id=1yIHt8JE1v3-d8VW_Z6Ypj74NtJ-ZZP5Y",
                       # TRIAL 2: "https://drive.google.com/open?id=1jS36CdH3jJiVdVXlE6GOkznP4Ao50o5m",
                       # TRIAL 1: "https://drive.google.com/open?id=1jZHlCKP8goQZ1W-nFXcaiBabxSTzEQv4",
                     destinationPath = destPath,
                     fun = "readRDS", targetFile = "model1.rds")
```

#### Plots  

First of all, we should check chain mixing. We use the function `chainsPlot` from the package `basicMCMCplots`. OBS.: These will likely not work in RStudio server.

```{r chains1, echo = TRUE}
if (TRIAL != "trial6"){
   betaChain <- prepParamForChainCheck(samplesList = model1$samples, 
                                    param = "beta", 
                                    unwantted = "sd")
} else {
betaChain <- prepParamForChainCheck(samplesList = model1$samples, 
                                    param = "beta", 
                                    unwantted = "tau.beta")  
}
# dev.off()
basicMCMCplots::chainsPlot(samplesList = betaChain)
# dev.off()
basicMCMCplots::chainsSummary(samplesList = betaChain)
# dev.off()
basicMCMCplots::samplesPlot(samples = betaChain)
```

After looking into chain mixing, we check lambda. Note that this is the summary average, not original posterior.
```{r lambda1, echo = TRUE}
# Original densities
originalDensities <- prepInputs(url = "https://drive.google.com/open?id=1KOmGJxRivRNgc8AAoCrinl7-ZHQOPUGm",
                     destinationPath = file.path(getwd(), "outputs/posthocAnalysis/bayesian/"),
                     fun = "readRDS")
modelDT <- data.table(model1$summary$all.chains, keep.rownames = TRUE)
lambda <- modelDT[rn %in% grepMulti(modelDT$rn, patterns = "lambda"),] 
hist(originalDensities, main = "Average density: Original", xlim = c(0, 3), breaks = 15) # Average density
hist(lambda[, Mean], main = "Average density: Model 1", xlim = c(0, 3), breaks = 30) # Average density
```

Now the coefficient for disturbance, beta. Beta[1] is the neighborhood disturbance coefficient, and beta[2] is the local disturbance coefficient.
```{r beta1, echo = TRUE}
if (TRIAL != "trial6"){
 beta <- c(grepMulti(modelDT$rn, patterns = c("beta", "1")),
                   grepMulti(modelDT$rn, patterns = c("beta", "2")),
                   grepMulti(modelDT$rn, patterns = c("beta", "mu")))
} else {
  beta <- c(grepMulti(modelDT$rn, patterns = c("beta", "1")),
                   grepMulti(modelDT$rn, patterns = c("beta", "2")),
                   grepMulti(modelDT$rn, patterns = c("beta", "mu", "1")),
                   grepMulti(modelDT$rn, patterns = c("beta", "mu", "2")))
}
dt <- data.frame(modelDT[rn %in% beta,c("rn", "Mean")])
boxplot(Mean ~ rn, data = dt, main = paste0("Disturbance Coefficients: ", whichModel), 
        xlab = "beta[1] = neighborhood; beta[2] = local\n mu.beta = hyperparameter average")
```

Now we look at the random effects for parameters: Year and Cluster
```{r RE1, echo = TRUE}
RE <- c(grepMulti(modelDT$rn, patterns = c("YearRanEff")),
          grepMulti(modelDT$rn, patterns = c("clusterRanEff")),
        grepMulti(modelDT$rn, patterns = c("phi")))
modelDT[rn %in% RE,]
dtRE <- data.frame(modelDT[rn %in% RE, c("rn", "Mean")])
# count how many 
ys <- length(grepMulti(dtRE$rn, "Year"))
cls <- length(grepMulti(dtRE$rn, "cluster"))
ph <- length(grepMulti(dtRE$rn, "phi"))
dtRE$RE <- c(rep("YearRandomEffect", times = ys), rep("ClusterRandomEffect", times = cls), rep("phi", times = ph))
boxplot(Mean ~ RE, data = dtRE, main = paste0("Random effects and habitat suitability: ", whichModel))
```

At last, we check habitat suitability: omega
```{r omega1, echo = TRUE}
chain1 <- data.table(model1$samples$chain1, keep.rownames = TRUE, check.names = TRUE)
omegaNames <- grepMulti(names(chain1), patterns = "omega")
omega <- chain1[, grepMulti(names(chain1), patterns = "omega")]
chain1Omega <- as.numeric(unlist(x = chain1[, ..omega], recursive = TRUE))

chain2 <- data.table(model1$samples$chain2, keep.rownames = TRUE, check.names = TRUE)
omegaNames <- grepMulti(names(chain2), patterns = "omega")
omega <- chain2[, grepMulti(names(chain2), patterns = "omega")]
allOmega <- c(chain2Omega, as.numeric(unlist(x = chain2[, ..omega], recursive = TRUE)))
hist(allOmega, main = paste0("Average Habitat Suitability: ", whichModel), xlab = "omega")
```

Correlation between beta[1] and beta[2]
```{r betaCorr1, echo = TRUE}
chain1 <- data.table(model1$samples$chain1, keep.rownames = TRUE, check.names = TRUE)
chain2 <- data.table(model1$samples$chain2, keep.rownames = TRUE, check.names = TRUE)

beta1 <- chain1[, grepMulti(names(chain1), patterns = c("beta", "1"))] # Same for chain 2
chain1beta1 <- chain1[, ..beta1]
chain2beta1 <- chain2[, ..beta1]
beta.neighborhood <- rbind(chain1beta1, chain2beta1)
beta2 <- chain1[, grepMulti(names(chain1), patterns = c("beta", "2"))]
chain1beta2 <- chain1[, ..beta2]
chain2beta2 <- chain2[, ..beta2]
beta.local <- rbind(chain2beta2, chain1beta2)
dt <- cbind(beta.local, beta.neighborhood)
names(dt) <- c("beta.local", "mu.beta.local", "beta.neighborhood", "mu.beta.neighborhood")
dt <- as.data.frame(dt)

clearPlot()
# BETA
plot(dt$beta.neighborhood, 
     dt$beta.local, xlab = "beta[1] - neighborhood", ylab = "beta[2] - local", main = whichModel)
mod <- lm(data = dt, beta.neighborhood ~ beta.local)
tab <- summary(mod)
abline(mod, col = "red")
mtext(paste0("cor = ", round(cor(dt$beta.neighborhood, dt$beta.local), 3), 
             "\nadj.R^2 = ", round(tab$adj.r.squared, 3)), 3, line = -0.2)

clearPlot()
# MU.BETA
plot(dt$mu.beta.neighborhood, 
     dt$mu.beta.local, xlab = "mu.beta[1] - neighborhood", ylab = "mu.beta[2] - local", main = whichModel)
mod <- lm(data = dt, mu.beta.neighborhood ~ mu.beta.local)
tab <- summary(mod)
abline(mod, col = "red")
mtext(paste0("cor = ", round(cor(dt$mu.beta.neighborhood, dt$mu.beta.local), 3), 
             "\nadj.R^2 = ", round(tab$adj.r.squared, 3)), 3, line = -0.2)

```


### Model 2: 
Model 2 is composed of two equations, one for neighborhood, one for local. Neighborhood lambda has a poisson distribution, and the coefficients for disturbance come from the same hyperprior.  
OBS.: NN needs to be initialized as well as local lambda

```{r model2_design, eval=FALSE}
          ################################### MODEL 2: 2 equations + ZI
    iSMCode <- nimbleCode({
      
      ######## PRIORS ########
      #Zero inflation - habitat suitability
      phi ~ dunif(0, 1) # proportion of suitable sites (we need to keep phi between 0 and 1)
      
      # Coefficient for disturbance
      mu.beta ~ dunif(-40, 40)
      tau.beta ~ T(dgamma(1, 1), 0.01, 100)
      sd.beta <- 1/pow(tau.beta, 2) # cluster heterogeneity in lambda
      for (b in 1:Nbeta) {
        beta[b] ~ dnorm(mu.beta, tau.beta) # Hyperparameter for beta coefficients # No idea what to put here!
      }
      tau.NN ~ T(dgamma(1, 1), 0.01, 100)
      sd.NN <- 1/pow(tau.NN, 2) # cluster heterogeneity in NN
      
      # Random effect
      tau.clusters ~ T(dgamma(1, 1), 0.01, 100)
      sd.cluster <- 1/pow(tau.clusters, 2) # year heterogeneity in lambda
      tau.year ~ T(dgamma(1, 1), 0.01, 100)
      sd.year <- 1/pow(tau.year, 2) # cluster heterogeneity in lambda
      for (j in 1:NClusters) {
        clusterRanEff[j] ~ dnorm(0, tau.clusters) # Note plural on tau.clusters, different than tau.clusters
        # random cluster effects in log(density)
      }
      for (y in 1:NYears) {
        YearRanEff[y] ~ dnorm(0, tau.year)
        # random year effects in log(density)
      }
      
      ##### END OF PRIORS ####
      
      for (i in 1:nvisits){ # each sample point / each row of the data table
        omega[i] ~ dbern(phi) # Habitat suitability --> zero inflation (if phi = 0, unsuitable)
        # Neighborhood scale
        yearInd <- YearIndex[i]
        clusterInd <- ClusterIndex[i]
        
        logNN[i] ~ dnorm(loglambdaN[i], tau.NN)
        loglambdaN[i] <- logDensity[i] +
          beta[1] * State_P_500[i] +
          offset[i] +
          clusterRanEff[clusterInd] * switchCluster +
          YearRanEff[yearInd] * switchYear # Random Effects
        
        # Local scale
        counts[i]  ~ dpois(lambdaLOmega[i])
        lambdaLOmega[i] <- omega[i] * lambdaL[i]
        lambdaL[i] <- exp(loglambdaL[i])
        loglambdaL[i] <- logNN[i] + beta[2] * State_P_100[i] # We can add an interceptL to NN?
      } # end i
    })
    
    ################################### MODEL
    
    # Data (doesn't need init)
    iSMdata <- list(counts = currentYearBirdData$counts,  
                    logDensity = currentYearBirdData$density, # Its says density, but it really is logDensity
                    State_P_100 = currentYearBirdData$State_P_100,
                    State_P_500 = currentYearBirdData$State_P_500,
                    offset = currentYearBirdData$offset,
                    ClusterIndex = currentYearBirdData$ClusterSP,
                    YearIndex = currentYearBirdData$YYYY)
    # Constants
    nvisits <- NROW(currentYearBirdData)
    NClusters <- length(unique(currentYearBirdData$ClusterSP))
    NYears <- length(unique(currentYearBirdData$YYYY))
    Nbeta <- 2 # Number of different beta coefficients (coming from the same hyperparameter)
    iSMconstants <- list(nvisits = nvisits,
                         NClusters = NClusters,
                         NYears = NYears,
                         Nbeta = Nbeta, # number of coefficients, currently: beta[1] and beta[2]
                         # Switches
                         switchYear = 1, # or 0 to turn off random effects of Year
                         switchCluster = 1 # or 0 to turn off random effects of Cluster
    )
    
    lambdaL <- runif(1, 0, 5)# Abundance. Needs reasonable values between 0 and 5?
    iSMinits <- list(
      # Coefficients
      phi = runif(1, 0, 1), # ZI part (‘suitability’ of the sample site).
      beta = rep(0, times = Nbeta), # Coefficient for disturbance ~ Has distribution, not sure need to provide
      omega = rep(1, times = nvisits), # Bernoulli of phi, sample site ‘suitability’ ~ Has distribution, not sure need to provide
      logNN = rep(1, times = nvisits), # Distribution of lambda1 ~ Has distribution, not sure need to provide
      lambdaLOmega = currentYearBirdData$counts, # Distribution of counts <- Is assigned, not sure need to provide # REMOVED FOR NOW --> Simplified
      lambdaL = lambdaL, # Local model, poisson of counts <- Is assigned
      loglambdaL = log(lambdaL), # log of lambda2
      tau.year = runif(1, 0.01, 10), # Deviation of year RE ~ Has distribution
      tau.clusters = runif(1, 0.01, 10), # Deviation of cluester RE ~ Has distribution
      tau.beta = runif(1, 0.01, 10), # Deviation of beta hyperparameter ~ Has distribution
      mu.beta = 0,
      tau.NN = runif(1, 0.01, 10), # Deviation of logNN
      YearRanEff = rep(0, times = NYears),
      clusterRanEff = rep(0, times = NClusters)
    )
    params <- c("beta", "mu.beta", "tau.beta", "sd.beta", 
                "loglambdaN", "sd.year", "sd.cluster", 
                "sd.NN", "logNN", "lambdaL", 
                "omega", "lambdaLOmega",
                "phi", "clusterRanEff", "YearRanEff")
  }
```

#### Loading 

```{r load2, echo=TRUE}
whichModel <- "Model 2"
model2 <- prepInputs(url = "https://drive.google.com/open?id=1AXPoAfzZMy9M0EEmtggSKnjLIAYwAo3W",
                       # TRIAL 5: "https://drive.google.com/open?id=1eTWpb-1mxYXX1KYZ66RvrXMB0_zyV1AB",
                       # TRIAL 4: "https://drive.google.com/open?id=1R6EReTfdLHtv8O3EeK1bwayfZgs-n4eh", 
                       # TRIAL 3: "https://drive.google.com/open?id=15d7j6wBj09a6XK1mF0C3cFLggrrqCao4",
                       # TRIAL 2: "https://drive.google.com/open?id=17QiG44vd-Tsf-7QZreUz8Vq67UmpDLZH",
                       # TRIAL 1: https://drive.google.com/open?id=1774Hwx9yFVkOn58eI5rEdGTerve6aqOA",
                     destinationPath = destPath,
                     fun = "readRDS", targetFile = "model2.rds")
```

#### Plots  

First of all, we should check chain mixing. We use the function `chainsPlot` from the package `basicMCMCplots`. OBS.: These will likely not work in RStudio server.

```{r chains2, echo = TRUE}
if (TRIAL != "trial6"){
   betaChain <- prepParamForChainCheck(samplesList = model2$samples, 
                                    param = "beta", 
                                    unwantted = "sd")
} else {
betaChain <- prepParamForChainCheck(samplesList = model2$samples, 
                                    param = "beta", 
                                    unwantted = "tau.beta")  
}

# dev.off()
basicMCMCplots::chainsPlot(samplesList = betaChain)
# dev.off()
basicMCMCplots::chainsSummary(samplesList = betaChain)
# dev.off()
basicMCMCplots::samplesPlot(samples = betaChain)
```

After looking into chain mixing, we check lambda. Note that this is the summary average, not original posterior.
```{r lambda2, echo = TRUE}
# Estimated densities
modelDT <- data.table(model2$summary$all.chains, keep.rownames = TRUE)
lambdaL <- modelDT[rn %in% grepMulti(modelDT$rn, patterns = "lambdaL"),]
lambdaN <- modelDT[rn %in% grepMulti(modelDT$rn, patterns = "lambdaN"),]
hist(originalDensities, main = "Average density: Original", xlim = c(0, 3), breaks = 15) # Average density
hist(lambdaL[,Mean], main = paste0("Average density local: ", whichModel), xlim = c(0, 3), breaks = 30) # Average density
hist(lambdaN[,Mean], main = paste0("Average density neighborhood: ", whichModel), xlim = c(0, 3), breaks = 30) # Average density
```

Now the coefficient for disturbance, beta. Beta[1] is the neighborhood disturbance coefficient, and beta[2] is the local disturbance coefficient.
```{r beta2, echo = TRUE}
beta <- c(grepMulti(modelDT$rn, patterns = c("beta", "1")),
                   grepMulti(modelDT$rn, patterns = c("beta", "2")),
                   grepMulti(modelDT$rn, patterns = c("beta", "mu")))
dt <- data.frame(modelDT[rn %in% beta,c("rn", "Mean")])
boxplot(Mean ~ rn, data = dt, main = paste0("Disturbance Coefficients: ", whichModel), 
        xlab = "beta[1] = neighborhood; beta[2] = local\n mu.beta = hyperparameter average")
```

Now we look at the random effects for parameters: Year and Cluster
```{r RE2, echo = TRUE}
RE <- c(grepMulti(modelDT$rn, patterns = c("YearRanEff")),
          grepMulti(modelDT$rn, patterns = c("clusterRanEff")),
        grepMulti(modelDT$rn, patterns = c("phi")))
modelDT[rn %in% RE,]
dtRE <- data.frame(modelDT[rn %in% RE, c("rn", "Mean")])
# count how many 
ys <- length(grepMulti(dtRE$rn, "Year"))
cls <- length(grepMulti(dtRE$rn, "cluster"))
ph <- length(grepMulti(dtRE$rn, "phi"))
dtRE$RE <- c(rep("YearRandomEffect", times = ys), rep("ClusterRandomEffect", times = cls), rep("phi", times = ph))
boxplot(Mean ~ RE, data = dtRE, main = paste0("Random effects and habitat suitability: ", whichModel))
```

At last, we check habitat suitability: omega
```{r omega2, echo = TRUE}
chain1 <- data.table(model2$samples$chain1, keep.rownames = TRUE, check.names = TRUE)
omegaNames <- grepMulti(names(chain1), patterns = "omega")
omega <- chain1[, grepMulti(names(chain1), patterns = "omega")]
chain1Omega <- as.numeric(unlist(x = chain1[, ..omega], recursive = TRUE))

chain2 <- data.table(model2$samples$chain2, keep.rownames = TRUE, check.names = TRUE)
omegaNames <- grepMulti(names(chain2), patterns = "omega")
omega <- chain2[, grepMulti(names(chain2), patterns = "omega")]
allOmega <- c(chain2Omega, as.numeric(unlist(x = chain2[, ..omega], recursive = TRUE)))
hist(allOmega, main = paste0("Average Habitat Suitability: ", whichModel), xlab = "omega")
```

Correlation between beta[1] and beta[2]
```{r betaCorr2, echo = TRUE}
chain1 <- data.table(model2$samples$chain1, keep.rownames = TRUE, check.names = TRUE)
chain2 <- data.table(model2$samples$chain2, keep.rownames = TRUE, check.names = TRUE)

beta1 <- chain1[, grepMulti(names(chain1), patterns = c("beta", "1"))] # Same for chain 2
chain1beta1 <- chain1[, ..beta1]
chain2beta1 <- chain2[, ..beta1]
beta.neighborhood <- rbind(chain1beta1, chain2beta1)
beta2 <- chain1[, grepMulti(names(chain1), patterns = c("beta", "2"))]
chain1beta2 <- chain1[, ..beta2]
chain2beta2 <- chain2[, ..beta2]
beta.local <- rbind(chain2beta2, chain1beta2)
dt <- cbind(beta.local, beta.neighborhood)
names(dt) <- c("beta.local", "beta.neighborhood")
dt <- as.data.frame(dt)

clearPlot()
plot(dt$beta.neighborhood, 
     dt$beta.local, xlab = "beta[1] - neighborhood", ylab = "beta[2] - local", main = whichModel)
mod <- lm(data = dt, beta.neighborhood ~ beta.local)
tab <- summary(mod)
abline(mod, col = "red")
mtext(paste0("cor = ", round(cor(dt$beta.neighborhood, dt$beta.local), 3), 
             "\nadj.R^2 = ", round(tab$adj.r.squared, 3)), 3, line = -0.2)
```


### Model 3: 
Model 3 is composed of one equation, where the coefficients for disturbance come from the same hyperprior, but has no Zero Inflation.
```{r model3_design, eval=FALSE}
         ################################### MODEL 3: 1 equation no ZI
    iSMCode <- nimbleCode({
      
      ######## PRIORS ########
      #Zero inflation - habitat suitability
      
      # Coefficient for disturbance
      mu.beta ~ dunif(-40, 40)
      tau.beta ~ T(dgamma(1, 1), 0.01, 100)
      sd.beta <- 1/pow(tau.beta, 2) # cluster heterogeneity in lambda
      for (b in 1:Nbeta) {
        beta[b] ~ dnorm(mu.beta, tau.beta) # Hyperparameter for beta coefficients # No idea what to put here!
      }
      
      # Random effect
      tau.clusters ~ T(dgamma(1, 1), 0.01, 100)
      sd.cluster <- 1/pow(tau.clusters, 2) # year heterogeneity in lambda
      tau.year ~ T(dgamma(1, 1), 0.01, 100)
      sd.year <- 1/pow(tau.year, 2) # cluster heterogeneity in lambda
      for (j in 1:NClusters) {
        clusterRanEff[j] ~ dnorm(0, tau.clusters) # Note plural on tau.clusters, different than tau.clusters
        # random cluster effects in log(density)
      }
      for (y in 1:NYears) {
        YearRanEff[y] ~ dnorm(0, tau.year)
        # random year effects in log(density)
      }
      
      ##### END OF PRIORS ####
      
      for (i in 1:nvisits){ # each sample point / each row of the data table
        # Local scale
        yearInd <- YearIndex[i]
        clusterInd <- ClusterIndex[i]
        counts[i]  ~ dpois(lambda[i])
        lambda[i] <- exp(loglambda[i])
        loglambda[i] <- logDensity[i] + beta[1] * State_P_500[i] + beta[2] * State_P_100[i] + offset[i] + 
          clusterRanEff[clusterInd] * switchCluster +
          YearRanEff[yearInd] * switchYear # Random Effects
      } # end i
    })
    
    ################################### MODEL
    
    # Data (doesn't need init)
    iSMdata <- list(counts = currentYearBirdData$counts,  
                    logDensity = currentYearBirdData$density,
                    State_P_100 = currentYearBirdData$State_P_100,
                    State_P_500 = currentYearBirdData$State_P_500,
                    offset = currentYearBirdData$offset,
                    ClusterIndex = currentYearBirdData$ClusterSP,
                    YearIndex = currentYearBirdData$YYYY)
    # Constants
    nvisits <- NROW(currentYearBirdData)
    NClusters <- length(unique(currentYearBirdData$ClusterSP))
    NYears <- length(unique(currentYearBirdData$YYYY))
    Nbeta <- 2 # Number of different beta coefficients (coming from the same hyperparameter)
    iSMconstants <- list(nvisits = nvisits,
                         NClusters = NClusters,
                         NYears = NYears,
                         Nbeta = Nbeta, # number of coefficients, currently: beta[1] and beta[2]
                         # Switches
                         switchYear = 1, # or 0 to turn off random effects of Year
                         switchCluster = 1 # or 0 to turn off random effects of Cluster
    )
    
    iSMinits <- list(
      # Coefficients
      beta = rep(0, times = Nbeta), # Coefficient for disturbance ~ Has distribution, not sure need to provide
      tau.year = runif(1, 0.01, 10), # Deviation of year RE ~ Has distribution
      tau.clusters = runif(1, 0.01, 10), # Deviation of cluester RE ~ Has distribution
      tau.beta = runif(1, 0.01, 10), # Deviation of beta hyperparameter ~ Has distribution
      mu.beta = 0,
      YearRanEff = rep(0, times = NYears),
      clusterRanEff = rep(0, times = NClusters)
    )
    
    params <- c("mu.beta", "beta", "tau.beta", "sd.beta", 
                "lambda",
                "clusterRanEff", "YearRanEff")
  }
```

#### Loading 

```{r load3, echo=TRUE}
whichModel <- "Model 3"
model3 <- prepInputs(url = "https://drive.google.com/open?id=1WOri5BstOs36AjaGLPhFMV_Cqv4VRInp",
                       # TRIAL 5: "https://drive.google.com/open?id=1HyHw09Uh2fQPQ0TUnjcutQ9ox-yTaSDJ",
                       # TRIAL 4: "https://drive.google.com/open?id=1d20NQmaGxD71JnFn5LWf9HW3M6esi__b",
                       # TRIAL 3: "https://drive.google.com/open?id=1MLKMU-oz7MgnIhJ8XoqLZ_f5ki57SWm2",
                       # TRIAL 2: "https://drive.google.com/open?id=1oVzMYvI7YXvL6TsgSh8BnYCda7GOAU2E",
                       # TRIAL 1: "https://drive.google.com/open?id=1UWoaLN1lNOjVQBSzSD2WpA1185i1x9ne",
                     destinationPath = destPath,
                     fun = "readRDS", targetFile = "model3.rds")
```

#### Plots  

First of all, we should check chain mixing. We use the function `chainsPlot` from the package `basicMCMCplots`. OBS.: These will likely not work in RStudio server.

```{r chains3, echo = TRUE}
if (TRIAL != "trial6"){
   betaChain <- prepParamForChainCheck(samplesList = model3$samples, 
                                    param = "beta", 
                                    unwantted = "sd")
} else {
betaChain <- prepParamForChainCheck(samplesList = model3$samples, 
                                    param = "beta", 
                                    unwantted = "tau.beta")  
}
Rchain <- prepParamForChainCheck(samplesList = model3$samples, 
                                    param = "R", 
                                    unwantted = NULL)
# dev.off()
basicMCMCplots::chainsPlot(samplesList = betaChain)
# dev.off()
basicMCMCplots::chainsSummary(samplesList = betaChain)
# dev.off()
basicMCMCplots::samplesPlot(samples = betaChain)
```


After looking into chain mixing, we check lambda. Note that this is the summary average, not original posterior.
```{r lambda3, echo = TRUE}
# Original densities
originalDensities <- prepInputs(url = "https://drive.google.com/open?id=1KOmGJxRivRNgc8AAoCrinl7-ZHQOPUGm",
                     destinationPath = file.path(getwd(), "outputs/posthocAnalysis/bayesian/"),
                     fun = "readRDS")
modelDT <- data.table(model3$summary$all.chains, keep.rownames = TRUE)
lambda <- modelDT[rn %in% grepMulti(modelDT$rn, patterns = "lambda"),] 
hist(originalDensities, main = "Average density: Original", xlim = c(0, 3), breaks = 15) # Average density
hist(lambda[, Mean], main = paste0("Average density: ", whichModel), xlim = c(0, 3), breaks = 15) # Average density
```

Now the coefficient for disturbance, beta. Beta[1] is the neighborhood disturbance coefficient, and beta[2] is the local disturbance coefficient.
```{r beta3, echo = TRUE}
beta <- c(grepMulti(modelDT$rn, patterns = c("beta", "1")),
                   grepMulti(modelDT$rn, patterns = c("beta", "2")),
                   grepMulti(modelDT$rn, patterns = c("beta", "mu")))
dt <- data.frame(modelDT[rn %in% beta,c("rn", "Mean")])
boxplot(Mean ~ rn, data = dt, main = paste0("Disturbance Coefficients: ", whichModel), 
        xlab = "beta[1] = neighborhood; beta[2] = local\n mu.beta = hyperparameter average")
```

Now we look at the random effects for parameters: Year and Cluster
```{r RE3, echo = TRUE}
RE <- c(grepMulti(modelDT$rn, patterns = c("YearRanEff")),
          grepMulti(modelDT$rn, patterns = c("clusterRanEff")))
modelDT[rn %in% RE,]
dtRE <- data.frame(modelDT[rn %in% RE, c("rn", "Mean")])
# count how many 
ys <- length(grepMulti(dtRE$rn, "Year"))
cls <- length(grepMulti(dtRE$rn, "cluster"))
dtRE$RE <- c(rep("YearRandomEffect", times = ys), rep("ClusterRandomEffect", times = cls))
boxplot(Mean ~ RE, data = dtRE, main = paste0("Random effects and habitat suitability: ", whichModel))
```

Correlation between beta[1] and beta[2]
```{r betaCorr3, echo = TRUE}
chain1 <- data.table(model3$samples$chain1, keep.rownames = TRUE, check.names = TRUE)
chain2 <- data.table(model3$samples$chain2, keep.rownames = TRUE, check.names = TRUE)

beta1 <- chain1[, grepMulti(names(chain1), patterns = c("beta", "1"))] # Same for chain 2
chain1beta1 <- chain1[, ..beta1]
chain2beta1 <- chain2[, ..beta1]
beta.neighborhood <- rbind(chain1beta1, chain2beta1)
beta2 <- chain1[, grepMulti(names(chain1), patterns = c("beta", "2"))]
chain1beta2 <- chain1[, ..beta2]
chain2beta2 <- chain2[, ..beta2]
beta.local <- rbind(chain2beta2, chain1beta2)
dt <- cbind(beta.local, beta.neighborhood)
names(dt) <- c("beta.local", "beta.neighborhood")
dt <- as.data.frame(dt)

clearPlot()
plot(dt$beta.neighborhood, 
     dt$beta.local, xlab = "beta[1] - neighborhood", ylab = "beta[2] - local", main = whichModel)
mod <- lm(data = dt, beta.neighborhood ~ beta.local)
tab <- summary(mod)
abline(mod, col = "red")
mtext(paste0("cor = ", round(cor(dt$beta.neighborhood, dt$beta.local), 3), 
             "\nadj.R^2 = ", round(tab$adj.r.squared, 3)), 3, line = -0.2)
```

### Model 4: 
Model 4 is composed of two equations, one for neighborhood, one for local. Neighborhood lambda has a poisson distribution, and the coefficients for disturbance come from the same hyperprior, but no Zero Inflation.
OBS.: NN needs to be initialized as well as local lambda

```{r model4_design, eval=FALSE}
        ################################### MODEL 4: 2 equations no ZI
    iSMCode <- nimbleCode({
      
      ######## PRIORS ########
      # Coefficient for disturbance
      mu.beta ~ dunif(-40, 40)
      tau.beta ~ T(dgamma(1, 1), 0.01, 100)
      sd.beta <- 1/pow(tau.beta, 2) # cluster heterogeneity in lambda
      for (b in 1:Nbeta) {
        beta[b] ~ dnorm(mu.beta, tau.beta) # Hyperparameter for beta coefficients # No idea what to put here!
      }
      tau.NN ~ T(dgamma(1, 1), 0.01, 100)
      sd.NN <- 1/pow(tau.NN, 2) # cluster heterogeneity in NN
      
      # Random effect
      tau.clusters ~ T(dgamma(1, 1), 0.01, 100)
      sd.cluster <- 1/pow(tau.clusters, 2) # year heterogeneity in lambda
      tau.year ~ T(dgamma(1, 1), 0.01, 100)
      sd.year <- 1/pow(tau.year, 2) # cluster heterogeneity in lambda
      for (j in 1:NClusters) {
        clusterRanEff[j] ~ dnorm(0, tau.clusters) # Note plural on tau.clusters, different than tau.clusters
        # random cluster effects in log(density)
      }
      for (y in 1:NYears) {
        YearRanEff[y] ~ dnorm(0, tau.year)
        # random year effects in log(density)
      }
      
      ##### END OF PRIORS ####
      
      for (i in 1:nvisits){ # each sample point / each row of the data table
        # Neighborhood scale
        yearInd <- YearIndex[i]
        clusterInd <- ClusterIndex[i]
        
        logNN[i] ~ dnorm(loglambdaN[i], tau.NN)
        loglambdaN[i] <- logDensity[i] +
          beta[1] * State_P_500[i] +
          offset[i] +
          clusterRanEff[clusterInd] * switchCluster +
          YearRanEff[yearInd] * switchYear # Random Effects
        
        # Local scale
        counts[i]  ~ dpois(lambdaL[i])
        lambdaL[i] <- exp(loglambdaL[i])
        loglambdaL[i] <- logNN[i] + beta[2] * State_P_100[i] # We can add an interceptL to NN?
      } # end i
    })
    
    ################################### MODEL
    
    # Data (doesn't need init)
    iSMdata <- list(counts = currentYearBirdData$counts,  
                    logDensity = currentYearBirdData$density,
                    State_P_100 = currentYearBirdData$State_P_100,
                    State_P_500 = currentYearBirdData$State_P_500,
                    offset = currentYearBirdData$offset,
                    ClusterIndex = currentYearBirdData$ClusterSP,
                    YearIndex = currentYearBirdData$YYYY)
    # Constants
    nvisits <- NROW(currentYearBirdData)
    NClusters <- length(unique(currentYearBirdData$ClusterSP))
    NYears <- length(unique(currentYearBirdData$YYYY))
    Nbeta <- 2 # Number of different beta coefficients (coming from the same hyperparameter)
    iSMconstants <- list(nvisits = nvisits,
                         NClusters = NClusters,
                         NYears = NYears,
                         Nbeta = Nbeta, # number of coefficients, currently: beta[1] and beta[2]
                         # Switches
                         switchYear = 1, # or 0 to turn off random effects of Year
                         switchCluster = 1 # or 0 to turn off random effects of Cluster
    )
    
    lambdaL <- runif(1, 0, 5)# Abundance. Needs reasonable values between 0 and 5?
    iSMinits <- list(
      # Coefficients
      beta = rep(0, times = Nbeta), # Coefficient for disturbance ~ Has distribution, not sure need to provide
      logNN = rep(1, times = nvisits), # Distribution of lambda1 ~ Has distribution, not sure need to provide
      lambdaL = lambdaL, # Local model, poisson of counts <- Is assigned
      loglambdaL = log(lambdaL), # log of lambda2
      tau.year = runif(1, 0.01, 10), # Deviation of year RE ~ Has distribution
      tau.clusters = runif(1, 0.01, 10), # Deviation of cluester RE ~ Has distribution
      tau.beta = runif(1, 0.01, 10), # Deviation of beta hyperparameter ~ Has distribution
      mu.beta = 0,
      tau.NN = runif(1, 0.01, 10), # Deviation of NN ~ Has distribution
      YearRanEff = rep(0, times = NYears),
      clusterRanEff = rep(0, times = NClusters)
    )
    params <- c("beta", "mu.beta", "tau.beta", "sd.beta", 
                "loglambdaN", 
                "logNN", "lambdaL", "sd.year", "sd.cluster", 
                "sd.NN",
                "clusterRanEff", "YearRanEff")
  }
```

#### Loading 

```{r load4, echo=TRUE}
whichModel <- "Model 4"
model4 <- prepInputs(url = "https://drive.google.com/open?id=1sjobb4TFJ6AXzAq_SePAg7ysck2o4oKG",
                       # TRIAL 5: "https://drive.google.com/open?id=1LeHxu3G5dVMWiGEsATbmNaACCdRdk9Ln",
                       # TRIAL 4: "https://drive.google.com/open?id=1WY0R9_Jkf7imMJ5ZqDsH2s9NrwmicPns",
                       # TRIAL 3: "https://drive.google.com/open?id=1HQhyWsSHY8w54yUZPAmnv-Kv-zz-qtj-",
                       # TRIAL 2: "https://drive.google.com/open?id=1yMFNbIF7aPm6nmaqrjnz4518BsO6644L",
                       # TRIAL 1 "https://drive.google.com/open?id=1YvG-FFvimDB_hHtSCsYfeZY9rwKfDjue",
                     destinationPath = destPath,
                     fun = "readRDS", targetFile = "model4.rds")
```

#### Plots  

First of all, we should check chain mixing. We use the function `chainsPlot` from the package `basicMCMCplots`. OBS.: These will likely not work in RStudio server.

```{r chains4, echo = TRUE}
betaChain <- prepParamForChainCheck(samplesList = model4$samples, 
                                    param = "beta", 
                                    unwantted = "sd")
# dev.off()
basicMCMCplots::chainsPlot(samplesList = betaChain)
# dev.off()
basicMCMCplots::chainsSummary(samplesList = betaChain)
# dev.off()
basicMCMCplots::samplesPlot(samples = betaChain)
```

After looking into chain mixing, we check lambda. Note that this is the summary average, not original posterior.
```{r lambda4, echo = TRUE}
# Estimated densities
modelDT <- data.table(model4$summary$all.chains, keep.rownames = TRUE)
lambdaL <- modelDT[rn %in% grepMulti(modelDT$rn, patterns = "lambdaL"),]
lambdaN <- modelDT[rn %in% grepMulti(modelDT$rn, patterns = "lambdaN"),]
hist(originalDensities, main = "Average density: Original", xlim = c(0, 3), breaks = 15) # Average density
hist(lambdaL[,Mean], main = paste0("Average density local: ", whichModel), xlim = c(0, 3), breaks = 30) # Average density
hist(lambdaN[,Mean], main = paste0("Average density neighborhood: ", whichModel), xlim = c(0, 3), breaks = 30) # Average density
```

Now the coefficient for disturbance, beta. Beta[1] is the neighborhood disturbance coefficient, and beta[2] is the local disturbance coefficient.
```{r beta4, echo = TRUE}
beta <- c(grepMulti(modelDT$rn, patterns = c("beta", "1")),
                   grepMulti(modelDT$rn, patterns = c("beta", "2")),
                   grepMulti(modelDT$rn, patterns = c("beta", "mu")))
dt <- data.frame(modelDT[rn %in% beta,c("rn", "Mean")])
boxplot(Mean ~ rn, data = dt, main = paste0("Disturbance Coefficients: ", whichModel), 
        xlab = "beta[1] = neighborhood; beta[2] = local\n mu.beta = hyperparameter average")
```

Now we look at the random effects for parameters: Year and Cluster
```{r RE4, echo = TRUE}
RE <- c(grepMulti(modelDT$rn, patterns = c("YearRanEff")),
          grepMulti(modelDT$rn, patterns = c("clusterRanEff")))
modelDT[rn %in% RE,]
dtRE <- data.frame(modelDT[rn %in% RE, c("rn", "Mean")])
# count how many 
ys <- length(grepMulti(dtRE$rn, "Year"))
cls <- length(grepMulti(dtRE$rn, "cluster"))
dtRE$RE <- c(rep("YearRandomEffect", times = ys), rep("ClusterRandomEffect", times = cls))
boxplot(Mean ~ RE, data = dtRE, main = paste0("Random effects and habitat suitability: ", whichModel))
```


Correlation between beta[1] and beta[2]
```{r betaCorr4, echo = TRUE}
chain1 <- data.table(model4$samples$chain1, keep.rownames = TRUE, check.names = TRUE)
chain2 <- data.table(model4$samples$chain2, keep.rownames = TRUE, check.names = TRUE)

beta1 <- chain1[, grepMulti(names(chain1), patterns = c("beta", "1"))] # Same for chain 2
chain1beta1 <- chain1[, ..beta1]
chain2beta1 <- chain2[, ..beta1]
beta.neighborhood <- rbind(chain1beta1, chain2beta1)
beta2 <- chain1[, grepMulti(names(chain1), patterns = c("beta", "2"))]
chain1beta2 <- chain1[, ..beta2]
chain2beta2 <- chain2[, ..beta2]
beta.local <- rbind(chain2beta2, chain1beta2)
dt <- cbind(beta.local, beta.neighborhood)
names(dt) <- c("beta.local", "beta.neighborhood")
dt <- as.data.frame(dt)

clearPlot()
plot(dt$beta.neighborhood, 
     dt$beta.local, xlab = "beta[1] - neighborhood", ylab = "beta[2] - local", main = whichModel)
mod <- lm(data = dt, beta.neighborhood ~ beta.local)
tab <- summary(mod)
abline(mod, col = "red")
mtext(paste0("cor = ", round(cor(dt$beta.neighborhood, dt$beta.local), 3), 
             "\nadj.R^2 = ", round(tab$adj.r.squared, 3)), 3, line = -0.2)
```

  
## Results summary:




