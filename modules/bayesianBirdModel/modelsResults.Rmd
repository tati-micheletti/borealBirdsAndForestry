---
title: "Hierarchical Model"
author: "Tati Micheletti"
date: "26/04/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reproducible)
library(quickPlot)
library(usefun)
library(ggplot2)
library(data.table)
library(googledrive)
Require("basicMCMCplots")
```

## Hierarchical scale model

### Model 1: 
Model 1 is composed of one equation, where the coefficients for disturbance come from the same hyperprior. 

```{r model1_design, eval=FALSE}
      for (i in 1:nvisits){ # each sample point / each row of the data table
        omega[i] ~ dbern(phi) # Habitat suitability --> zero inflation (if phi = 0, unsuitable)
        # Local scale
        yearInd <- YearIndex[i]
        clusterInd <- ClusterIndex[i]
        counts[i]  ~ dpois(mu.poisson[i])
        mu.poisson[i] <- omega[i] * lambda[i] 
        lambda[i] <- exp(loglambda[i])
        loglambda[i] <- density[i] + beta[1] * State_P_500[i] + beta[2] * State_P_100[i] + offset[i] + 
          clusterRanEff[clusterInd] * switchCluster +
          YearRanEff[yearInd] * switchYear # Random Effects
      } # end i
```

#### Loading 

```{r load1, echo=TRUE}
model1 <- prepInputs(url = "https://drive.google.com/open?id=1s4sgskS9DyQGBtOLrgqphmx70fHmZzJP",
                     destinationPath = tempdir(),
                     fun = "readRDS")
```

#### Plots  

First of all, we should check chain mixing. We use the function `chainsPlot` from the package `basicMCMCplots`. OBS.: These will likely not work in RStudio server.

```{r chains1, echo = TRUE, eval = FALSE}
basicMCMCplots::chainsPlot(samplesList = model1$samples)
basicMCMCplots::chainsSummary(samplesList = model1$samples)
basicMCMCplots::samplesPlot(samples = model1$samples)
```


After looking into chain mixing, we check lambda. Note that this is the summary average, not original posterior.
```{r lambda1, echo = TRUE}
# Original densities
originalDensities <- prepInputs(url = "https://drive.google.com/open?id=1KOmGJxRivRNgc8AAoCrinl7-ZHQOPUGm",
                     destinationPath = tempdir(),
                     fun = "readRDS")
model1DT <- data.table(model1$summary$all.chains, keep.rownames = TRUE)
lambda <- model1DT[rn %in% grepMulti(model1DT$rn, patterns = "lambda"),] 
hist(originalDensities, main = "Average density: Original", xlim = c(0, 3), breaks = 15) # Average density
hist(lambda[, Mean], main = "Average density: Model 1", xlim = c(0, 3), breaks = 30) # Average density
```

Now the coefficient for disturbance, beta. Beta[1] is the neighborhood disturbance coefficient, and beta[2] is the local disturbance coefficient.
```{r beta1, echo = TRUE}
beta <- c(grepMulti(model1DT$rn, patterns = c("beta", "1")),
                   grepMulti(model1DT$rn, patterns = c("beta", "2")),
                   grepMulti(model1DT$rn, patterns = c("beta", "mu")))
dt <- data.frame(model1DT[rn %in% beta,c("rn", "Mean")])
boxplot(Mean ~ rn, data = dt, main = "Disturbance Coefficients: Model 1", xlab = "beta[1] = neighborhood; beta[2] = local\n mu.beta = hyperparameter average")
```

Now we look at the random effects for parameters: Year and Cluster
```{r RE1, echo = TRUE}
RE <- c(grepMulti(model1DT$rn, patterns = c("YearRanEff")),
          grepMulti(model1DT$rn, patterns = c("clusterRanEff")))
model1DT[rn %in% RE,]
dtRE <- data.frame(model1DT[rn %in% RE, c("rn", "Mean")])
# count how many 
ys <- length(grepMulti(dtRE$rn, "Year"))
dtRE$RE <- c(rep("YearRandomEffect", times = ys), rep("ClusterRandomEffect", times = NROW(dtRE)-ys))
boxplot(Mean ~ RE, data = dtRE, main = "Random effects: Model 1")
```

At last, we check habitat suitability: omega
```{r omega1, echo = TRUE}
chain1 <- data.table(model1$samples$chain1, keep.rownames = TRUE, check.names = TRUE)
omegaNames <- grepMulti(names(chain1), patterns = "omega")
omega <- chain1[, grepMulti(names(chain1), patterns = "omega")]
chain1Omega <- as.numeric(unlist(x = chain1[, ..omega], recursive = TRUE))

chain2 <- data.table(model1$samples$chain2, keep.rownames = TRUE, check.names = TRUE)
omegaNames <- grepMulti(names(chain2), patterns = "omega")
omega <- chain2[, grepMulti(names(chain2), patterns = "omega")]
allOmega <- c(chain1Omega, as.numeric(unlist(x = chain2[, ..omega], recursive = TRUE)))
hist(allOmega, main = "Average Habitat Suitability: Model 1", xlab = "omega")
```


### Model 2: 
Model 2 is composed of two equations, one for neighborhood, one for local. Neighborhood lambda has a poisson distribution, and the coefficients for disturbance come from the same hyperprior.  
OBS.: NN needs to be initialized as well as local lambda

```{r model2_design, eval=FALSE}
      for (i in 1:nvisits){ # each sample point / each row of the data table
        omega[i] ~ dbern(phi) # Habitat suitability --> zero inflation (if phi = 0, unsuitable)
        # Neighborhood scale
        yearInd <- YearIndex[i]
        clusterInd <- ClusterIndex[i]
        
        NN[i] ~ dpois(mu.poissonN[i])
        mu.poissonN[i] <- omega[i] * lambdaN[i] 
        lambdaN[i] <- exp(loglambdaN[i])
        
        loglambdaN[i] <- density[i] +
          beta[1] * State_P_500[i] +
          offset[i] +
          clusterRanEff[clusterInd] * switchCluster +
          YearRanEff[yearInd] * switchYear # Random Effects
        
        # Local scale
        counts[i]  ~ dpois(mu.poissonL[i])
        mu.poissonL[i] <- omega[i] * lambdaL[i] 
        lambdaL[i] <- exp(loglambdaL[i])
        loglambdaL[i] <- NN[i] + beta[2] * State_P_100[i] # We can add an interceptL to NN?
      } # end i
```

#### Loading 

```{r load2, echo=TRUE}
model2 <- prepInputs(url = "https://drive.google.com/open?id=1Op4klDDQztsemVnSiobfmfW0dYKR-tvm",
                     destinationPath = tempdir(),
                     fun = "readRDS")
```

#### Plots  

First of all, we should check chain mixing. We use the function `chainsPlot` from the package `basicMCMCplots`. OBS.: These will likely not work in RStudio server.

```{r chains2, echo = TRUE, eval = FALSE}
basicMCMCplots::chainsPlot(samplesList = model2$samples)
basicMCMCplots::chainsSummary(samplesList = model2$samples)
basicMCMCplots::samplesPlot(samples = model2$samples)
```

After looking into chain mixing, we check lambda. Note that this is the summary average, not original posterior.
```{r lambda2, echo = TRUE}
# Estimated densities
model2DT <- data.table(model2$summary$all.chains, keep.rownames = TRUE)
lambdaL <- model2DT[rn %in% grepMulti(model2DT$rn, patterns = "lambdaL"),]
lambdaN <- model2DT[rn %in% grepMulti(model2DT$rn, patterns = "lambdaN"),]
hist(originalDensities, main = "Average density: Original", xlim = c(0, 3), breaks = 15) # Average density
hist(lambdaL[,Mean], main = "Average density local: Model 2", xlim = c(0, 3), breaks = 30) # Average density
hist(lambdaN[,Mean], main = "Average density neighborhood: Model 2", xlim = c(0, 3), breaks = 30) # Average density
```

Now the coefficient for disturbance, beta. Beta[1] is the neighborhood disturbance coefficient, and beta[2] is the local disturbance coefficient.
```{r beta2, echo = TRUE}
beta <- c(grepMulti(model2DT$rn, patterns = c("beta", "1")),
                   grepMulti(model2DT$rn, patterns = c("beta", "2")),
                   grepMulti(model2DT$rn, patterns = c("beta", "mu")))
dt <- data.frame(model2DT[rn %in% beta,c("rn", "Mean")])
boxplot(Mean ~ rn, data = dt, main = "Disturbance Coefficients: Model 2", xlab = "beta[1] = neighborhood; beta[2] = local\n mu.beta = hyperparameter average")
```

Now we look at the random effects for parameters: Year and Cluster
```{r RE2, echo = TRUE}
RE <- c(grepMulti(model2DT$rn, patterns = c("YearRanEff")),
          grepMulti(model2DT$rn, patterns = c("clusterRanEff")))
model2DT[rn %in% RE,]
dtRE <- data.frame(model2DT[rn %in% RE, c("rn", "Mean")])
# count how many 
ys <- length(grepMulti(dtRE$rn, "Year"))
dtRE$RE <- c(rep("YearRandomEffect", times = ys), rep("ClusterRandomEffect", times = NROW(dtRE)-ys))
boxplot(Mean ~ RE, data = dtRE, main = "Random effects: Model 2")
```

At last, we check habitat suitability: omega
```{r omega2, echo = TRUE}
chain2 <- data.table(model2$samples$chain2, keep.rownames = TRUE, check.names = TRUE)
omegaNames <- grepMulti(names(chain2), patterns = "omega")
omega <- chain2[, grepMulti(names(chain2), patterns = "omega")]
chain2Omega <- as.numeric(unlist(x = chain2[, ..omega], recursive = TRUE))

chain2 <- data.table(model2$samples$chain2, keep.rownames = TRUE, check.names = TRUE)
omegaNames <- grepMulti(names(chain2), patterns = "omega")
omega <- chain2[, grepMulti(names(chain2), patterns = "omega")]
allOmega <- c(chain2Omega, as.numeric(unlist(x = chain2[, ..omega], recursive = TRUE)))
hist(allOmega, main = "Average Habitat Suitability: Model 2", xlab = "omega")
```

## Results summary:

*Model 1 (one equation)*  
  - Higher habitat suitability proportion  
  - Apparently more realistic densities (in comparison to Solymos& Stralberg densities)  
  - RE around 0  
  - Less negative beta coefficients  

*Model 2 (two equations)*  
  - Lower habitat suitability proportion,  
  - Apparently less realistic densities (in comparison to Solymos& Stralberg densities)  
  - RE around 0  
  - Less negative beta coefficients  
  
  
## Conclusion: Model 1 seems better  



